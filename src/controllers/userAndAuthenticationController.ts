/**
 * Beepo Core MicroserviceLib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

import { ApiResponse, RequestOptions } from '../core';
import {
  CreateUSERRequest,
  createUSERRequestSchema,
} from '../models/createUSERRequest';
import { Example1, example1Schema } from '../models/example1';
import { Example11, example11Schema } from '../models/example11';
import {
  LogInforAccessTokenRequest,
  logInforAccessTokenRequestSchema,
} from '../models/logInforAccessTokenRequest';
import { string } from '../schema';
import { BaseController } from './baseController';

export class UserAndAuthenticationController extends BaseController {
  /**
   * **Create USER**
   *
   * This endpoint creates a new user. It requires that a crypto context exists already, that is, It
   * requires the ID of the already created context.
   *
   * See the **create context** section in **security and encryption** for more details.
   *
   * The return data is the user object together with account seed phrase encrypted with the crypto
   * context used. The client decrypts it to get the 12-word seed phrase.
   *
   * @param body
   * @return Response from the API call
   */
  async createUSER(
    body: CreateUSERRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<Example1>> {
    const req = this.createRequest('POST', '/users');
    const mapped = req.prepareArgs({ body: [body, createUSERRequestSchema] });
    req.header('Content-Type', 'application/json');
    req.json(mapped.body);
    return req.callAsJson(example1Schema, requestOptions);
  }

  /**
   * **Log In for Access Token**
   *
   * This endpoint allows the client to request for an access token. It takes two required data fields.
   *
   * \*   The SHA256 hash of the client's seed phrase
   * \*   The SHA512 hash of the client's seed phrase
   *
   *
   * These two fields must be encrypted with the current context before sending the message to the server.
   * The server decrypts the message and determines if the credential is valid and then returns an
   * access token.
   *
   * The access token return is also encrypted by server using the current context, the client has to
   * decrypt it and then encrypt it again before it is attached to subsequent request for the purpose of
   * authentication.
   *
   * @param beepoCoreContextId    The id of the crypto context to use for RSA
   *                                                                   encryption/decryption between the server and
   *                                                                   client.
   * @param body
   * @return Response from the API call
   */
  async logInforAccessToken(
    beepoCoreContextId: string,
    body: LogInforAccessTokenRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<Example11>> {
    const req = this.createRequest('POST', '/auth/login');
    const mapped = req.prepareArgs({
      beepoCoreContextId: [beepoCoreContextId, string()],
      body: [body, logInforAccessTokenRequestSchema],
    });
    req.header('beepo-core-context-id', mapped.beepoCoreContextId);
    req.header('Content-Type', 'application/json');
    req.json(mapped.body);
    return req.callAsJson(example11Schema, requestOptions);
  }
}
