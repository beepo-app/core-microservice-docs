/**
 * Beepo Core MicroserviceLib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

import { ApiResponse, RequestOptions } from '../core';
import {
  AESSymmetricDecryptionRequest,
  aESSymmetricDecryptionRequestSchema,
} from '../models/aESSymmetricDecryptionRequest';
import {
  AESsymmetricEncryptionRequest,
  aESsymmetricEncryptionRequestSchema,
} from '../models/aESsymmetricEncryptionRequest';
import {
  CreateContextRequest,
  createContextRequestSchema,
} from '../models/createContextRequest';
import { Example12, example12Schema } from '../models/example12';
import { Example13, example13Schema } from '../models/example13';
import { Example14, example14Schema } from '../models/example14';
import { Example15, example15Schema } from '../models/example15';
import { Example16, example16Schema } from '../models/example16';
import { Example17, example17Schema } from '../models/example17';
import { Example18, example18Schema } from '../models/example18';
import { Example19, example19Schema } from '../models/example19';
import {
  RSADecryptionRequest,
  rSADecryptionRequestSchema,
} from '../models/rSADecryptionRequest';
import {
  RSAEncryptionRequest,
  rSAEncryptionRequestSchema,
} from '../models/rSAEncryptionRequest';
import { BaseController } from './baseController';

export class SecurityAndCryptoController extends BaseController {
  /**
   * **Generate RSA Keypair**
   *
   * This endpoint generate a new RSA keypair for RSA asymmetric encryption. The public and private keys
   * are returned in **PEM** format.
   *
   * @return Response from the API call
   */
  async generateRSAKeypair(
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<Example12>> {
    const req = this.createRequest('GET', '/crypto/rsa/keypair');
    return req.callAsJson(example12Schema, requestOptions);
  }

  /**
   * **AES Symmetric Encryption**
   *
   * Encrypt a message using AES-256 in CBC mode encryption. Pass the **message** and **key** and you the
   * **encrypted** text and **initialization vector (iv)**.
   *
   * @param body
   * @return Response from the API call
   */
  async aESsymmetricEncryption(
    body: AESsymmetricEncryptionRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<Example13>> {
    const req = this.createRequest('POST', '/crypto/aes-encrypt');
    const mapped = req.prepareArgs({
      body: [body, aESsymmetricEncryptionRequestSchema],
    });
    req.header('Content-Type', 'application/json');
    req.json(mapped.body);
    return req.callAsJson(example13Schema, requestOptions);
  }

  /**
   * **AES Symmetric Decryption**
   *
   * Decrypt an encrypted message using AES-256 in CBC mode encryption. Pass the ciphertext,
   * **encrypted**, the initialization vector, **iv** and **key** to get the original message.
   *
   * @param body
   * @return Response from the API call
   */
  async aESSymmetricDecryption(
    body: AESSymmetricDecryptionRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<Example14>> {
    const req = this.createRequest('POST', '/crypto/aes-decrypt');
    const mapped = req.prepareArgs({
      body: [body, aESSymmetricDecryptionRequestSchema],
    });
    req.header('Content-Type', 'application/json');
    req.json(mapped.body);
    return req.callAsJson(example14Schema, requestOptions);
  }

  /**
   * **Encrypt a message using a RSA public key. The public key must be in PEM format.**
   *
   * \*   Padding of PKCS1
   * \*   Output of encryption is in hex format.
   * \*   Input is expected to be a UTF-8 string
   *
   * @param body
   * @return Response from the API call
   */
  async rSAEncryption(
    body: RSAEncryptionRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<Example15>> {
    const req = this.createRequest('POST', '/crypto/rsa/encrypt');
    const mapped = req.prepareArgs({
      body: [body, rSAEncryptionRequestSchema],
    });
    req.header('Content-Type', 'application/json');
    req.json(mapped.body);
    return req.callAsJson(example15Schema, requestOptions);
  }

  /**
   * **Decrypt a ciphertext using a RSA private key. The private key must be in PEM format.**
   *
   * \*   Padding of PKCS1
   * \*   Output of decryption is in UTF-8 string.
   * \*   Input is expected to be in hex format.
   *
   * @param body
   * @return Response from the API call
   */
  async rSADecryption(
    body: RSADecryptionRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<Example16>> {
    const req = this.createRequest('POST', '/crypto/rsa/decrypt');
    const mapped = req.prepareArgs({
      body: [body, rSADecryptionRequestSchema],
    });
    req.header('Content-Type', 'application/json');
    req.json(mapped.body);
    return req.callAsJson(example16Schema, requestOptions);
  }

  /**
   * **RSA Context**
   *
   * This endpoint instructs the server to create a new RSA encryption/decryption context for future
   * encryption/decryption operations between the client and server. The client supplies its own
   * **publicKey**, the server then generates and saves a new context, and returns the context
   * **publicKey** and **contextId** to the client. The client can then encrypt messages for the server
   * simply by using the returned **publicKey** and attaching the **contextId** into a header field so
   * the server can determine which context to use to decrypt the message.
   *
   * You can create as many contexts as you want and switch between them for encryption/decryption,
   * however, A single context per instance of the client is recommended.
   *
   * When you change your context, all login tokens issued with the previous context become invalid for
   * that context, as such, you must request for a new access token.
   *
   * **How to state the context used**
   *
   * Stating the context to use in a request cycle requires that the ID of the context be attached to the
   * request. It must be attached in a request header, with a key of **beepo-core-context-id** and the
   * value is the ID.
   *
   * **An error 400** with a reason is returned if the server cannot validate the context. It could be
   * due to a context that does not exist or an invalidated context.
   *
   * @param body
   * @return Response from the API call
   */
  async createContext(
    body: CreateContextRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<Example17>> {
    const req = this.createRequest('POST', '/crypto/rsa/new-context');
    const mapped = req.prepareArgs({
      body: [body, createContextRequestSchema],
    });
    req.header('Content-Type', 'application/json');
    req.json(mapped.body);
    return req.callAsJson(example17Schema, requestOptions);
  }

  /**
   * **Fetch Context**
   *
   * Fetch a context that was previously created from the database. The public key, **publicKey**, of the
   * client must be supplied in order to locate the corresponding context.
   *
   * @return Response from the API call
   */
  async fetchContext(
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<Example18>> {
    const req = this.createRequest('GET', '/crypto/rsa/fetch-context');
    return req.callAsJson(example18Schema, requestOptions);
  }

  /**
   * **Calculate the SHA256 hash of the message.**
   *
   * @param body
   * @return Response from the API call
   */
  async hashSHA256(
    body: Example16,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<Example19>> {
    const req = this.createRequest('POST', '/crypto/hashing/sha256');
    const mapped = req.prepareArgs({ body: [body, example16Schema] });
    req.header('Content-Type', 'application/json');
    req.json(mapped.body);
    return req.callAsJson(example19Schema, requestOptions);
  }

  /**
   * **Calculate the SHA512 hash of the message.**
   *
   * @param body
   * @return Response from the API call
   */
  async hashSHA512(
    body: Example16,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<Example19>> {
    const req = this.createRequest('POST', '/crypto/hashing/sha512');
    const mapped = req.prepareArgs({ body: [body, example16Schema] });
    req.header('Content-Type', 'application/json');
    req.json(mapped.body);
    return req.callAsJson(example19Schema, requestOptions);
  }
}
